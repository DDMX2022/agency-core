import fs from "node:fs";
import path from "node:path";
import type { LLMProvider } from "../../providers/llm-provider.js";
import type {
  ImplementorOutput,
  ImplementorAction,
  PipelineContext,
} from "../schemas/index.js";
import {
  evaluateActions,
  type PermissionPolicy,
} from "../permissions/index.js";

/**
 * Implementor Agent
 * Executes the plan by generating real file-creation and command actions.
 * All actions are gated through the permissions system.
 * At L1+ it writes actual files to the workspace sandbox.
 */
export class Implementor {
  constructor(
    private readonly llm: LLMProvider,
    private readonly policy: PermissionPolicy,
  ) {}

  async run(_input: string, context: PipelineContext): Promise<ImplementorOutput> {
    const guide = context.guide;
    const obs = context.observer;
    if (!guide || !obs) {
      throw new Error("Implementor requires Guide and Observer output in context");
    }

    const root = this.getAllowedRoot();

    // Generate actions from the plan — use LLM for real file content
    const proposedActions: ImplementorAction[] = [];
    for (const step of guide.plan) {
      if (step.action === "Verify all sub-problems are resolved") continue;

      const filename = toFilename(step.action);
      const filePath = path.join(root, filename);
      const content = await this.generateContent(step.action, obs.summary);

      proposedActions.push({
        type: "createFile" as const,
        path: filePath,
        content,
        requiresApproval: false, // No approval needed for createFile actions
        isDestructive: false,
      });
    }

    // Evaluate permissions
    const { allowed, blocked } = evaluateActions(proposedActions, this.policy);

    // Execute allowed actions — write real files
    const filesCreated: string[] = [];
    for (const action of allowed) {
      if (action.type === "createFile" && action.path && action.content) {
        await this.createFile(action.path, action.content);
        filesCreated.push(action.path);
      }
    }

    return {
      agent: "Implementor",
      actions: proposedActions,
      explanation: `Generated ${proposedActions.length} actions from ${guide.plan.length}-step plan. ${blocked.length} blocked by permissions. ${filesCreated.length} files written.`,
      filesCreated,
      filesModified: [],
      commandsRun: [],
      blocked: blocked.map(
        (b) => `${b.action.type}${b.action.path ? ` (${b.action.path})` : ""}: ${b.result.reason}`,
      ),
      timestamp: new Date().toISOString(),
    };
  }

  private getAllowedRoot(): string {
    return this.policy.allowedWorkspacePaths[0] ?? "./sandbox";
  }

  /**
   * Ask LLM to generate real file content for a plan step.
   * Falls back to a stub comment if LLM fails.
   */
  private async generateContent(action: string, projectSummary: string): Promise<string> {
    try {
      const system = "You are a senior TypeScript developer. Generate the full file content for the given task. Return ONLY the file code, no markdown fences, no explanation.";
      const user = `Task: ${action}\nProject context: ${projectSummary}`;

      const code = await this.llm.generate(system, user);
      if (code && code.trim().length > 10) {
        return code.trim();
      }
    } catch {
      // fall through to stub
    }
    return `// ${action}\n// Generated by Implementor\nexport {};\n`;
  }

  /**
   * Write a file to disk, creating parent directories as needed.
   */
  private async createFile(filePath: string, content: string): Promise<void> {
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, content, "utf-8");
  }
}

function toFilename(action: string): string {
  return (
    action
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .slice(0, 40) + ".ts"
  );
}