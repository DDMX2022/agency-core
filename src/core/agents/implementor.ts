import type { LLMProvider } from "../../providers/llm-provider.js";
import type {
  ImplementorOutput,
  ImplementorAction,
  PipelineContext,
} from "../schemas/index.js";
import {
  evaluateActions,
  type PermissionPolicy,
} from "../permissions/index.js";

/**
 * Implementor Agent
 * Executes the plan by generating file-creation and command actions.
 * All actions are gated through the permissions system.
 */
export class Implementor {
  constructor(
    private readonly llm: LLMProvider,
    private readonly policy: PermissionPolicy,
  ) {}

  async run(_input: string, context: PipelineContext): Promise<ImplementorOutput> {
    const guide = context.guide;
    const obs = context.observer;
    if (!guide || !obs) {
      throw new Error("Implementor requires Guide and Observer output in context");
    }

    await this.llm.generate(
      "Implementor: Execute the plan, produce code artifacts.",
      JSON.stringify({ plan: guide.plan, domain: obs.domain }),
    );

    // Generate actions from the plan
    const proposedActions: ImplementorAction[] = guide.plan
      .filter((step) => step.action !== "Verify all sub-problems are resolved")
      .map((step) => ({
        type: "createFile" as const,
        path: `${this.getAllowedRoot()}/${toFilename(step.action)}`,
        content: `// ${step.action}\n// Generated by Implementor\nexport {};\n`,
        requiresApproval: false,
        isDestructive: false,
      }));

    // Evaluate permissions
    const { allowed, blocked } = evaluateActions(proposedActions, this.policy);

    return {
      agent: "Implementor",
      actions: proposedActions,
      explanation: `Generated ${proposedActions.length} actions from ${guide.plan.length}-step plan. ${blocked.length} blocked by permissions.`,
      filesCreated: allowed
        .filter((a) => a.type === "createFile" && a.path)
        .map((a) => a.path!),
      filesModified: [],
      commandsRun: [],
      blocked: blocked.map(
        (b) => `${b.action.type}${b.action.path ? ` (${b.action.path})` : ""}: ${b.result.reason}`,
      ),
      timestamp: new Date().toISOString(),
    };
  }

  private getAllowedRoot(): string {
    return this.policy.allowedWorkspacePaths[0] ?? "./sandbox";
  }
}

function toFilename(action: string): string {
  return (
    action
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .slice(0, 40) + ".ts"
  );
}
